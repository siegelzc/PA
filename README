Debugging Tool for Assembly/Verilog

Verilog Logging Tool
~~~~~~~~~~~~~~~~~~~~
Put the log.v file in the same folder as the main verilog file.
Note that in order for the logger to work, the following signals must exist in the cpu.v file:
(the signals don't have to be part of the implementation, but I needed to have standard signal names. Just add it to the file as a log helper variable)
All signals valid in writeback:
    isSub, isMovl, isMovh, isJz, isJnz, isJs, isJns, isLd, isSt,
    clk, isJumping (jump taken), retired (indicates a instruction has completed execution this cycle, and a log entry
    should be written), reg_addr (register write address), reg_data, mem_addr (memory write address), mem_data

Architecture
~~~~~~~~~~~~

- memory is byte addressable

- words are 16 bits

- 16 register names r0, r1, ..., r15 (16 bits each)

    - r0 is special:
    * reading from r0 always returns 0
    * writing to r0 interprets the the least significant
    8 bits as an ASCII code and prints that character

    - all instructions are 16 bit wide

    encoding          instruction   description

    0000aaaabbbbtttt  sub ra rb rt  regs[t] = regs[a] - regs[b]
    0001aaaabbbbtttt  add ra rb rt  regs[t] = regs[a] + regs[b]
    0010aaaabbbbtttt  mul ra rb rt  regs[t] = regs[a] * regs[b]

    1000iiiiiiiitttt  movl i rt     regs[t] = sign_extend(i)
    1001iiiiiiiitttt  movh i rt     regs[t] = (regs[t] & 0xff) | (i << 8)

    1011aaaa0000tttt  mov ra rt     regs[t] = reg[a]
    1011aaaa0001tttt  swp ra rt     regs[t] = reg[a],  regs[a] = regs[t]

    1110aaaa0000tttt  jz ra rt      pc = (regs[ra] == 0) ? regs[rt] : pc + 2
    1110aaaa0001tttt  jnz ra rt     pc = (regs[ra] != 0) ? regs[rt] : pc + 2
    1110aaaa0010tttt  js ra rt      pc = (regs[ra] < 0) ? regs[rt] : pc + 2
    1110aaaa0011tttt  jns ra rt     pc = (regs[ra] >= 0) ? regs[rt] : pc + 2

    1111aaaa0000tttt  ld ra rt      regs[t] = mem[regs[a]]
    1111aaaa0001tttt  st ra rt      mem[regs[a]] = regs[t]

