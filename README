Debugging Tool for Assembly/Verilog

Usage Instructions
~~~~~~~~~~~~~~~~~~
1) Compile log.v with the rest of your verilog files (easiest thing would be to include it in the same folder as cpu.v)

2) Invoke ISM/vdb [ASSEMBLY FILE PATH] [COMPILED CPU FILE PATH]
    Run ISM/vdb --help for info

3) Do not move any files in ISM/, this may cause unexpected behavior

Architecture
~~~~~~~~~~~~

- memory is byte addressable

- words are 16 bits

- 16 register names r0, r1, ..., r15 (16 bits each)

    - r0 is special:
    * reading from r0 always returns 0
    * writing to r0 interprets the the least significant
    8 bits as an ASCII code and prints that character

    NOTE: When a jump is used, a movl instruction is inserted before the
        jump instruction, moving the address of the label into rt.
        SUBNOTE: This limits the address of the label to a byte
    - all instructions are 16 bit wide

    encoding          instruction   description

    0000aaaabbbbtttt  sub ra rb rt  regs[t] = regs[a] - regs[b]
    0001aaaabbbbtttt  add ra rb rt  regs[t] = regs[a] + regs[b]
    0010aaaabbbbtttt  mul ra rb rt  regs[t] = regs[a] * regs[b]

    1000iiiiiiiitttt  movl i rt     regs[t] = sign_extend(i)
    1001iiiiiiiitttt  movh i rt     regs[t] = (regs[t] & 0xff) | (i << 8)

    1011aaaa0000tttt  mov ra rt     regs[t] = reg[a]

    1110aaaa0000tttt  jz ra label rt      pc = (regs[ra] == 0) ? regs[rt] : pc + 2
    1110aaaa0001tttt  jnz ra label rt     pc = (regs[ra] != 0) ? regs[rt] : pc + 2
    1110aaaa0010tttt  js ra label rt      pc = (regs[ra] < 0) ? regs[rt] : pc + 2
    1110aaaa0011tttt  jns ra label rt     pc = (regs[ra] >= 0) ? regs[rt] : pc + 2

    1111aaaa0000tttt  ld ra rt      regs[t] = mem[regs[a]]
    1111aaaa0001tttt  st ra rt      mem[regs[t]] = regs[a]


Documentation
~~~~~~~~~~~~~
assembler.py : Assembles a assembly program into hexadecimal bytecode
    Usage: assembler.py [ASSEMBLY FILE PATH]
    - produces a .hex file of the same name in the same directory as the given file
log.v : Interfaces with the cpu.v file using the following signals:
    Note that in order for the logger to work, the following signals must exist in the cpu.v file:
    (the signals don't have to be part of the implementation, but I needed to have standard signal names. Just add it to the file as a log helper variable)
    All signals valid in writeback:
        isSub, isMovl, isMovh, isJz, isJnz, isJs, isJns, isLd, isSt,
        clk, isJumping (jump taken), retired (indicates a instruction has completed execution this cycle, and a log entry
        should be written), reg_addr (register write address), reg_data, mem_addr (memory write address), mem_data
parser.py : Parses and decodes the bytecode, generating an organized sequence of instruction objects
    (used internally by ism.py)
ism.py : Simulates the processor by independently running the byte code generated by the assembler
    Usage: ism.py [HEX FILE PATH]
    - Produces logs in ISM/logs/ which are used by vdb (ism.log, ism.out, ism_pc.csv, ism_regs.csv, ism_mem.csv)
logReader.py : Reads the log output of the verilog simulator and produces csv files (stored int ISM/logs/)
    logReader.py [HEX FILE PATH] [CPU LOG FILE]
    - CPU LOG FILE is produced by log.v when the Verilog simulator is run
    - produces vlog_pc.csv, vlog_regs.csv, vlog_mem.csv
debugger.py : Runs a gdb-style debugging tool by traversing the csv tables generated in ism.py and logReader.py
    Usage: debugger.py path/to/logs/ism_pc.csv path/to/logs/vlog_pc.csv path/to/logs/ism_regs.csv path/to/logs/vlog_regs.csv path/to/logs/ism_mem.csv path/to/logs/vlog_mem.csv
vdb : Links all of the above scripts together into a coherent tool (also runs the cpu simulation)
    Usage: vdb [ASSEMBLY FILE PATH] [CPU EXECUTABLE PATH]
